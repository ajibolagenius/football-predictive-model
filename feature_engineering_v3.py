import pandas as pd
from sqlalchemy import create_engine

DB_CONNECTION = "postgresql://postgres@localhost:5432/football_prediction_db"

def get_db_engine():
    return create_engine(DB_CONNECTION)

def calculate_rest_days(df):
    """Calculates Fatigue."""
    df['date'] = pd.to_datetime(df['date'])
    # Stack home and away to get a single timeline per team
    home = df[['date', 'home_team_id']].rename(columns={'home_team_id': 'team_id'})
    away = df[['date', 'away_team_id']].rename(columns={'away_team_id': 'team_id'})
    all_matches = pd.concat([home, away]).sort_values(['team_id', 'date'])
    
    all_matches['rest_days'] = all_matches.groupby('team_id')['date'].diff().dt.days.fillna(7)
    
    # Merge back
    df = df.merge(all_matches, left_on=['date', 'home_team_id'], right_on=['date', 'team_id'], how='left').rename(columns={'rest_days': 'home_rest'})
    df = df.drop('team_id', axis=1)
    df = df.merge(all_matches, left_on=['date', 'away_team_id'], right_on=['date', 'team_id'], how='left').rename(columns={'rest_days': 'away_rest'})
    df = df.drop('team_id', axis=1)
    return df

def process_features_v3():
    engine = get_db_engine()
    print("ðŸ“¥ Loading raw data for V3 Engineering...")
    
    query = """
    SELECT m.match_id, m.date, m.home_team_id, m.away_team_id, m.home_goals, m.away_goals, s.home_xg, s.away_xg
    FROM matches m JOIN match_stats s ON m.match_id = s.match_id
    ORDER BY m.date ASC;
    """
    df = pd.read_sql(query, engine)
    
    # 1. Rest Days
    df = calculate_rest_days(df)
    
    # 2. Venue Specific Rolling Stats (The Upgrade)
    print("ðŸ”„ Calculating Home-Specific and Away-Specific Form...")
    
    # We define points
    df['h_pts'] = df.apply(lambda x: 3 if x['home_goals'] > x['away_goals'] else (1 if x['home_goals'] == x['away_goals'] else 0), axis=1)
    df['a_pts'] = df.apply(lambda x: 3 if x['away_goals'] > x['home_goals'] else (1 if x['home_goals'] == x['away_goals'] else 0), axis=1)

    # Rolling Home Stats (Only look at previous HOME games for the home team)
    df['home_goals_last_3_at_home'] = df.groupby('home_team_id')['home_goals'].transform(lambda x: x.rolling(3, min_periods=1).mean().shift(1))
    df['home_xg_last_3_at_home'] = df.groupby('home_team_id')['home_xg'].transform(lambda x: x.rolling(3, min_periods=1).mean().shift(1))
    
    # Rolling Away Stats (Only look at previous AWAY games for the away team)
    df['away_goals_last_3_at_away'] = df.groupby('away_team_id')['away_goals'].transform(lambda x: x.rolling(3, min_periods=1).mean().shift(1))
    df['away_xg_last_3_at_away'] = df.groupby('away_team_id')['away_xg'].transform(lambda x: x.rolling(3, min_periods=1).mean().shift(1))

    # General Form (Last 5 regardless of venue - keeping this as context)
    # (Simplified for brevity - merging logic similar to previous versions)
    # For V3, we will rely on the venue specific ones + General xG
    
    # Drop NaNs generated by rolling
    df.dropna(inplace=True)
    
    # Target
    def get_res(row):
        if row['home_goals'] > row['away_goals']: return 2
        elif row['home_goals'] == row['away_goals']: return 1
        else: return 0
    df['match_result'] = df.apply(get_res, axis=1)
    
    print(f"ðŸ“Š Features V3 Ready: {len(df)} matches.")
    df.to_sql('model_features_v3', engine, if_exists='replace', index=False)
    print("âœ¨ Saved to 'model_features_v3'")

if __name__ == "__main__":
    process_features_v3()